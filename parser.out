Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BREAK
    CASE
    CLASS
    COLON
    COMMENT
    CONST
    CONTINUE
    DIVEQ
    DOT
    ELSE
    EQEQ
    EQUALS
    EXTENDS
    FINAL
    FOR
    IF
    IMPLEMENTS
    IMPORT
    INTDIV
    LBRACKET
    MAXSIGN
    MAXSIGNEQ
    MINSIGN
    MINSIGNEQ
    MINUSEQ
    MODULE
    NEQ
    NOT
    NULLASSIGN
    NULLCOALESCING
    OR
    PLUSEQ
    QMARK_DOT
    RBRACKET
    RETURN
    SQUOTE
    STRING_LITERAL
    SWITCH
    THEN
    TIMESEQ
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> function_list
Rule 2     program -> <empty>
Rule 3     function_list -> function function_list
Rule 4     function_list -> <empty>
Rule 5     function -> type ID LPAREN parameters RPAREN block
Rule 6     parameters -> parameter_list
Rule 7     parameters -> <empty>
Rule 8     parameter_list -> parameter COMMA parameter_list
Rule 9     parameter_list -> parameter
Rule 10    parameter_list -> <empty>
Rule 11    parameter -> type ID
Rule 12    expression -> expression PLUS term
Rule 13    expression -> expression MINUS term
Rule 14    expression -> term
Rule 15    term -> term TIMES factor
Rule 16    term -> term DIVIDE factor
Rule 17    term -> factor
Rule 18    factor -> NUMBER
Rule 19    factor -> LPAREN expression RPAREN
Rule 20    block -> LBRACES statements RBRACES
Rule 21    statements -> statement statements
Rule 22    statements -> <empty>
Rule 23    statement -> expression SEMICOLON
Rule 24    type -> INT
Rule 25    type -> DOUBLE
Rule 26    type -> BOOL
Rule 27    type -> STRING
Rule 28    type -> VAR

Terminals, with rules where they appear

AND                  : 
BOOL                 : 26
BREAK                : 
CASE                 : 
CLASS                : 
COLON                : 
COMMA                : 8
COMMENT              : 
CONST                : 
CONTINUE             : 
DIVEQ                : 
DIVIDE               : 16
DOT                  : 
DOUBLE               : 25
ELSE                 : 
EQEQ                 : 
EQUALS               : 
EXTENDS              : 
FINAL                : 
FOR                  : 
ID                   : 5 11
IF                   : 
IMPLEMENTS           : 
IMPORT               : 
INT                  : 24
INTDIV               : 
LBRACES              : 20
LBRACKET             : 
LPAREN               : 5 19
MAXSIGN              : 
MAXSIGNEQ            : 
MINSIGN              : 
MINSIGNEQ            : 
MINUS                : 13
MINUSEQ              : 
MODULE               : 
NEQ                  : 
NOT                  : 
NULLASSIGN           : 
NULLCOALESCING       : 
NUMBER               : 18
OR                   : 
PLUS                 : 12
PLUSEQ               : 
QMARK_DOT            : 
RBRACES              : 20
RBRACKET             : 
RETURN               : 
RPAREN               : 5 19
SEMICOLON            : 23
SQUOTE               : 
STRING               : 27
STRING_LITERAL       : 
SWITCH               : 
THEN                 : 
TIMES                : 15
TIMESEQ              : 
VAR                  : 28
WHILE                : 
error                : 

Nonterminals, with rules where they appear

block                : 5
expression           : 12 13 19 23
factor               : 15 16 17
function             : 3
function_list        : 1 3
parameter            : 8 9
parameter_list       : 6 8
parameters           : 5
program              : 0
statement            : 21
statements           : 20 21
term                 : 12 13 14 15 16
type                 : 5 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function_list
    (2) program -> .
    (3) function_list -> . function function_list
    (4) function_list -> .
    (5) function -> . type ID LPAREN parameters RPAREN block
    (24) type -> . INT
    (25) type -> . DOUBLE
    (26) type -> . BOOL
    (27) type -> . STRING
    (28) type -> . VAR

  ! reduce/reduce conflict for $end resolved using rule 2 (program -> .)
    $end            reduce using rule 2 (program -> .)
    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    BOOL            shift and go to state 7
    STRING          shift and go to state 8
    VAR             shift and go to state 9

  ! $end            [ reduce using rule 4 (function_list -> .) ]

    program                        shift and go to state 1
    function_list                  shift and go to state 2
    function                       shift and go to state 3
    type                           shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> function_list .

    $end            reduce using rule 1 (program -> function_list .)


state 3

    (3) function_list -> function . function_list
    (3) function_list -> . function function_list
    (4) function_list -> .
    (5) function -> . type ID LPAREN parameters RPAREN block
    (24) type -> . INT
    (25) type -> . DOUBLE
    (26) type -> . BOOL
    (27) type -> . STRING
    (28) type -> . VAR

    $end            reduce using rule 4 (function_list -> .)
    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    BOOL            shift and go to state 7
    STRING          shift and go to state 8
    VAR             shift and go to state 9

    function                       shift and go to state 3
    function_list                  shift and go to state 10
    type                           shift and go to state 4

state 4

    (5) function -> type . ID LPAREN parameters RPAREN block

    ID              shift and go to state 11


state 5

    (24) type -> INT .

    ID              reduce using rule 24 (type -> INT .)


state 6

    (25) type -> DOUBLE .

    ID              reduce using rule 25 (type -> DOUBLE .)


state 7

    (26) type -> BOOL .

    ID              reduce using rule 26 (type -> BOOL .)


state 8

    (27) type -> STRING .

    ID              reduce using rule 27 (type -> STRING .)


state 9

    (28) type -> VAR .

    ID              reduce using rule 28 (type -> VAR .)


state 10

    (3) function_list -> function function_list .

    $end            reduce using rule 3 (function_list -> function function_list .)


state 11

    (5) function -> type ID . LPAREN parameters RPAREN block

    LPAREN          shift and go to state 12


state 12

    (5) function -> type ID LPAREN . parameters RPAREN block
    (6) parameters -> . parameter_list
    (7) parameters -> .
    (8) parameter_list -> . parameter COMMA parameter_list
    (9) parameter_list -> . parameter
    (10) parameter_list -> .
    (11) parameter -> . type ID
    (24) type -> . INT
    (25) type -> . DOUBLE
    (26) type -> . BOOL
    (27) type -> . STRING
    (28) type -> . VAR

  ! reduce/reduce conflict for RPAREN resolved using rule 7 (parameters -> .)
    RPAREN          reduce using rule 7 (parameters -> .)
    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    BOOL            shift and go to state 7
    STRING          shift and go to state 8
    VAR             shift and go to state 9

  ! RPAREN          [ reduce using rule 10 (parameter_list -> .) ]

    type                           shift and go to state 13
    parameters                     shift and go to state 14
    parameter_list                 shift and go to state 15
    parameter                      shift and go to state 16

state 13

    (11) parameter -> type . ID

    ID              shift and go to state 17


state 14

    (5) function -> type ID LPAREN parameters . RPAREN block

    RPAREN          shift and go to state 18


state 15

    (6) parameters -> parameter_list .

    RPAREN          reduce using rule 6 (parameters -> parameter_list .)


state 16

    (8) parameter_list -> parameter . COMMA parameter_list
    (9) parameter_list -> parameter .

    COMMA           shift and go to state 19
    RPAREN          reduce using rule 9 (parameter_list -> parameter .)


state 17

    (11) parameter -> type ID .

    COMMA           reduce using rule 11 (parameter -> type ID .)
    RPAREN          reduce using rule 11 (parameter -> type ID .)


state 18

    (5) function -> type ID LPAREN parameters RPAREN . block
    (20) block -> . LBRACES statements RBRACES

    LBRACES         shift and go to state 21

    block                          shift and go to state 20

state 19

    (8) parameter_list -> parameter COMMA . parameter_list
    (8) parameter_list -> . parameter COMMA parameter_list
    (9) parameter_list -> . parameter
    (10) parameter_list -> .
    (11) parameter -> . type ID
    (24) type -> . INT
    (25) type -> . DOUBLE
    (26) type -> . BOOL
    (27) type -> . STRING
    (28) type -> . VAR

    RPAREN          reduce using rule 10 (parameter_list -> .)
    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    BOOL            shift and go to state 7
    STRING          shift and go to state 8
    VAR             shift and go to state 9

    parameter                      shift and go to state 16
    parameter_list                 shift and go to state 22
    type                           shift and go to state 13

state 20

    (5) function -> type ID LPAREN parameters RPAREN block .

    INT             reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)
    DOUBLE          reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)
    BOOL            reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)
    STRING          reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)
    VAR             reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)
    $end            reduce using rule 5 (function -> type ID LPAREN parameters RPAREN block .)


state 21

    (20) block -> LBRACES . statements RBRACES
    (21) statements -> . statement statements
    (22) statements -> .
    (23) statement -> . expression SEMICOLON
    (12) expression -> . expression PLUS term
    (13) expression -> . expression MINUS term
    (14) expression -> . term
    (15) term -> . term TIMES factor
    (16) term -> . term DIVIDE factor
    (17) term -> . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    RBRACES         reduce using rule 22 (statements -> .)
    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    statements                     shift and go to state 23
    statement                      shift and go to state 24
    expression                     shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 22

    (8) parameter_list -> parameter COMMA parameter_list .

    RPAREN          reduce using rule 8 (parameter_list -> parameter COMMA parameter_list .)


state 23

    (20) block -> LBRACES statements . RBRACES

    RBRACES         shift and go to state 30


state 24

    (21) statements -> statement . statements
    (21) statements -> . statement statements
    (22) statements -> .
    (23) statement -> . expression SEMICOLON
    (12) expression -> . expression PLUS term
    (13) expression -> . expression MINUS term
    (14) expression -> . term
    (15) term -> . term TIMES factor
    (16) term -> . term DIVIDE factor
    (17) term -> . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    RBRACES         reduce using rule 22 (statements -> .)
    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    statement                      shift and go to state 24
    statements                     shift and go to state 31
    expression                     shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 25

    (23) statement -> expression . SEMICOLON
    (12) expression -> expression . PLUS term
    (13) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 32
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34


state 26

    (14) expression -> term .
    (15) term -> term . TIMES factor
    (16) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 14 (expression -> term .)
    PLUS            reduce using rule 14 (expression -> term .)
    MINUS           reduce using rule 14 (expression -> term .)
    RPAREN          reduce using rule 14 (expression -> term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 27

    (17) term -> factor .

    TIMES           reduce using rule 17 (term -> factor .)
    DIVIDE          reduce using rule 17 (term -> factor .)
    SEMICOLON       reduce using rule 17 (term -> factor .)
    PLUS            reduce using rule 17 (term -> factor .)
    MINUS           reduce using rule 17 (term -> factor .)
    RPAREN          reduce using rule 17 (term -> factor .)


state 28

    (18) factor -> NUMBER .

    TIMES           reduce using rule 18 (factor -> NUMBER .)
    DIVIDE          reduce using rule 18 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 18 (factor -> NUMBER .)
    PLUS            reduce using rule 18 (factor -> NUMBER .)
    MINUS           reduce using rule 18 (factor -> NUMBER .)
    RPAREN          reduce using rule 18 (factor -> NUMBER .)


state 29

    (19) factor -> LPAREN . expression RPAREN
    (12) expression -> . expression PLUS term
    (13) expression -> . expression MINUS term
    (14) expression -> . term
    (15) term -> . term TIMES factor
    (16) term -> . term DIVIDE factor
    (17) term -> . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    expression                     shift and go to state 37
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 30

    (20) block -> LBRACES statements RBRACES .

    INT             reduce using rule 20 (block -> LBRACES statements RBRACES .)
    DOUBLE          reduce using rule 20 (block -> LBRACES statements RBRACES .)
    BOOL            reduce using rule 20 (block -> LBRACES statements RBRACES .)
    STRING          reduce using rule 20 (block -> LBRACES statements RBRACES .)
    VAR             reduce using rule 20 (block -> LBRACES statements RBRACES .)
    $end            reduce using rule 20 (block -> LBRACES statements RBRACES .)


state 31

    (21) statements -> statement statements .

    RBRACES         reduce using rule 21 (statements -> statement statements .)


state 32

    (23) statement -> expression SEMICOLON .

    NUMBER          reduce using rule 23 (statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 23 (statement -> expression SEMICOLON .)
    RBRACES         reduce using rule 23 (statement -> expression SEMICOLON .)


state 33

    (12) expression -> expression PLUS . term
    (15) term -> . term TIMES factor
    (16) term -> . term DIVIDE factor
    (17) term -> . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    term                           shift and go to state 38
    factor                         shift and go to state 27

state 34

    (13) expression -> expression MINUS . term
    (15) term -> . term TIMES factor
    (16) term -> . term DIVIDE factor
    (17) term -> . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    term                           shift and go to state 39
    factor                         shift and go to state 27

state 35

    (15) term -> term TIMES . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    factor                         shift and go to state 40

state 36

    (16) term -> term DIVIDE . factor
    (18) factor -> . NUMBER
    (19) factor -> . LPAREN expression RPAREN

    NUMBER          shift and go to state 28
    LPAREN          shift and go to state 29

    factor                         shift and go to state 41

state 37

    (19) factor -> LPAREN expression . RPAREN
    (12) expression -> expression . PLUS term
    (13) expression -> expression . MINUS term

    RPAREN          shift and go to state 42
    PLUS            shift and go to state 33
    MINUS           shift and go to state 34


state 38

    (12) expression -> expression PLUS term .
    (15) term -> term . TIMES factor
    (16) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 12 (expression -> expression PLUS term .)
    PLUS            reduce using rule 12 (expression -> expression PLUS term .)
    MINUS           reduce using rule 12 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 12 (expression -> expression PLUS term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 39

    (13) expression -> expression MINUS term .
    (15) term -> term . TIMES factor
    (16) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 13 (expression -> expression MINUS term .)
    PLUS            reduce using rule 13 (expression -> expression MINUS term .)
    MINUS           reduce using rule 13 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 13 (expression -> expression MINUS term .)
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36


state 40

    (15) term -> term TIMES factor .

    TIMES           reduce using rule 15 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 15 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 15 (term -> term TIMES factor .)
    PLUS            reduce using rule 15 (term -> term TIMES factor .)
    MINUS           reduce using rule 15 (term -> term TIMES factor .)
    RPAREN          reduce using rule 15 (term -> term TIMES factor .)


state 41

    (16) term -> term DIVIDE factor .

    TIMES           reduce using rule 16 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 16 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 16 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 16 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 16 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 16 (term -> term DIVIDE factor .)


state 42

    (19) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 19 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 19 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 19 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 19 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 19 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 19 (factor -> LPAREN expression RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 0 resolved using rule (program -> <empty>)
WARNING: rejected rule (function_list -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 12 resolved using rule (parameters -> <empty>)
WARNING: rejected rule (parameter_list -> <empty>) in state 12
